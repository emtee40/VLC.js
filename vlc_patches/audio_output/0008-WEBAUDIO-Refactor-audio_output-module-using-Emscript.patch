From eb4b2137bc44d4b91d67df8d444d085a51ea4809 Mon Sep 17 00:00:00 2001
From: Louis SANTUCCI <louis.santucci@epita.fr>
Date: Fri, 3 Dec 2021 19:27:08 +0100
Subject: [PATCH 1/1] [WEBAUDIO] Refactor audio_output module using Emscripten
 C API

Refactored emscripten.cpp file, we have now C API in webaudio/, it is
used in emscripten.c
---
 modules/audio_output/emscripten.c             |  58 +++----
 .../webaudio/audio-worklet-processor.js       |  62 +++----
 modules/audio_output/webaudio/webaudio.c      |  47 +++---
 modules/audio_output/webaudio/webaudio.h      |  33 ++--
 modules/audio_output/webaudio/webaudio.js     | 157 +++++++-----------
 5 files changed, 156 insertions(+), 201 deletions(-)

diff --git a/modules/audio_output/emscripten.c b/modules/audio_output/emscripten.c
index 6b9b909a..86bd1865 100644
--- a/modules/audio_output/emscripten.c
+++ b/modules/audio_output/emscripten.c
@@ -16,6 +16,9 @@
 #include <stdbool.h>
 #include <emscripten.h>
 #include <emscripten/html5.h>
+#include <emscripten/threading.h>
+
+#include <stdatomic.h>
 
 #include "webaudio/webaudio.h"
 
@@ -38,10 +41,17 @@ int Start(audio_output_t *aout, audio_sample_format_t *restrict fmt)
     fmt->i_channels = 2;
     fmt->i_rate = 44100;
 
+    // resume audio context (first start, it is paused when initialized)
+    // WRONG, should use js_index_store wrapper
+    //js_index_store(sys->sab, IS_PAUSED, 0);
+    atomic_store(&sys->sab->is_paused, 0);
+
+    MAIN_THREAD_EM_ASM({Module.audiocontext.resume()});
+
     return VLC_SUCCESS;
 }
 
-int Flush(audio_output_t *aout)
+void Flush(audio_output_t *aout)
 {
     aout_sys_t *sys = (aout_sys_t *) aout->sys;
     bzero(&sys->sab->storage, sizeof(sys->sab->storage));
@@ -55,34 +65,38 @@ void Play(audio_output_t *aout, block_t *block, vlc_tick_t date)
     int8_t *data = (int8_t *) block->p_buffer;
     size_t data_size = block->i_buffer;
 
-    uint32_t head = sys->sab->head;//.load();
-    uint32_t tail = sys->sab->tail;//.load();
+    uint32_t head = atomic_load(&sys->sab->head);//.load();
+    uint32_t tail = atomic_load(&sys->sab->tail);//.load();
     uint32_t new_head = (head + data_size) % STORAGE_SIZE;
+    // printf("Old Head : %d\nNew head : %d\nTail : %d\n", head, new_head, tail);
     if (new_head > tail)
     {
         // the worklet processor keeps rendering  until tail matches head
         // it will be notified by an Atomics.notify() from the process() callback
         // FIXME - This is layout-dependent, which isn't ideal
         js_index_wait(sys->sab, CAN_WRITE, 0);
+        //emscripten_futex_wait(&sys->sab->can_write, 0, 5000);
     }
-
-    audio_worklet_push(aout, data, data_size);
+    // Print to display data, instead of really pushing it, for test purposes
+    // printf("pushing data pointer: %p of size %d\n", data, data_size);
+    audio_worklet_push(sys->sab, data, data_size);
     block_Release(block);
-
 }
 
-int Pause(audio_output_t *aout, bool paused, vlc_tick_t date)
+void Pause(audio_output_t *aout, bool paused, vlc_tick_t date)
 {
     // Set is_paused
     VLC_UNUSED(date);
     aout_sys_t * sys = (aout_sys_t *) aout->sys;
     if (paused == false) {
-        //sys->sab->is_paused.store(0);
-        js_index_store(sys->sab, IS_PAUSED, 0);
+        //js_index_store(sys->sab, IS_PAUSED, 0);
+        atomic_store(&sys->sab->is_paused, 0);
+        MAIN_THREAD_EM_ASM({Module.audiocontext.resume()});
     }
     else {
-        //sys->sab->is_paused.store(1);
-        js_index_store(sys->sab, IS_PAUSED, 1);
+        //js_index_store(sys->sab, IS_PAUSED, 1);
+        atomic_store(&sys->sab->is_paused, 1);
+        MAIN_THREAD_EM_ASM({Module.audiocontext.suspend()});
     }
     Flush(aout);
 }
@@ -90,7 +104,6 @@ int Pause(audio_output_t *aout, bool paused, vlc_tick_t date)
 int Volume_Set(audio_output_t *aout, float volume)
 {
     aout_sys_t *sys = (aout_sys_t *) aout->sys;
-
     if (volume > 1.0f)
         volume = 1.0f;
     else if (volume < 0.0f)
@@ -98,9 +111,8 @@ int Volume_Set(audio_output_t *aout, float volume)
     // TODO: implement gain
     // Note: We store volume as an integer between 0..100 because
     // for some reason Float32Array doesn't allow atomic operations
-    
-    // sys->sab->volume.store((int)(volume * 100));
-    js_index_store(sys->sab, VOLUME, (int) volume * 100);
+    //js_index_store(sys->sab, VOLUME, (int) volume * 100);
+    atomic_store(&sys->sab->volume, (int) (volume * 100));
     aout_VolumeReport(aout, volume);
 
     return 0;
@@ -111,7 +123,7 @@ int Time_Get(audio_output_t *aout, vlc_tick_t *delay)
     return aout_TimeGetDefault(aout, delay);
 }
 
-int Close(vlc_object_t *obj)
+void Close(vlc_object_t *obj)
 {
     audio_output_t *aout = (audio_output_t *) obj;
     aout_sys_t *sys = (aout_sys_t *) aout->sys;
@@ -124,7 +136,7 @@ int Mute_Set(audio_output_t *aout, bool mute)
 {
     aout_sys_t *sys = (aout_sys_t *) aout->sys;
 
-    //    sys->sab->is_muted.store(mute);
+    atomic_store(&sys->sab->is_muted, mute);
     aout_MuteReport(aout, mute);
 
     return 0;
@@ -160,18 +172,6 @@ int Open(vlc_object_t *obj)
     sys->sab = init(44100, 2, true);
     sys->sab->volume = 100;
 
-    // sys->sab = init(44100, 2, true);
-
-    // if (sys->sab == NULL)
-    // {
-    //     return VLC_ENOMEM;
-    // }
-    
-    // Useless?
-    // bzero(sys->sab, sizeof(sound_buffer_t));
-
-
-
     return VLC_SUCCESS;
 }
 
diff --git a/modules/audio_output/webaudio/audio-worklet-processor.js b/modules/audio_output/webaudio/audio-worklet-processor.js
index 4fbfe190..d3524548 100644
--- a/modules/audio_output/webaudio/audio-worklet-processor.js
+++ b/modules/audio_output/webaudio/audio-worklet-processor.js
@@ -1,9 +1,9 @@
 class Processor extends AudioWorkletProcessor {
-    constructor() {
-    super();
-    this.port.onmessage = e => {
-        console.log("e data ", e.data)
-        if (e.data.type === 'recv-audio-queue') {
+  constructor() {
+  super();
+  this.port.onmessage = e => {
+    console.log("e data : ", e.data)
+    if (e.data.type === "recv-audio-queue") {
         this.is_paused = e.data.is_paused;
         this.head = e.data.head;
         this.tail = e.data.tail;
@@ -11,46 +11,46 @@ class Processor extends AudioWorkletProcessor {
         this.volume = e.data.volume;
         this.is_muted = e.data.is_muted;
         this.storage = e.data.storage;
-        } else {
+      } else {
         throw 'unexpected.';
-        }
+      }
     };
-    }
+  }
 
-    process(inputs, outputs, parameters) {
+  process(inputs, outputs, parameters) {
     const output = outputs[0];
     const nbChannels = output.length;
     const nbSamples = output[0].length;
-    if (this.head.buffer.byteLength == 0) {
-        throw new Error('wasmMemory grew');
+    if (this.head.buffer.byteLength === 0) {
+      throw new Error('wasmMemory grew');
     }
-    var head = Atomics.load(this.head, 0) / 4;
-    var tail = Atomics.load(this.tail, 0) / 4;
-    console.log("Head: ", head, ", Tail: ", tail);
+    var head = Atomics.load(this.head, 0) / 4; // Divides by 4 to make it int8, initially int32, simplifies the process
+    var tail = Atomics.load(this.tail, 0) / 4;  // Same
+
     var i = 0;
-    //var volume = Atomics.load(this.volume, 0) / 100;
-    if (Atomics.load(this.is_paused, 0) != 0 || Atomics.load(this.is_muted, 0) != 0) {
-        volume = 0;
+
+    var volume = Atomics.load(this.volume, 0) / 100;
+    if (Atomics.load(this.is_paused, 0) !== 0 || Atomics.load(this.is_muted, 0) !== 0) {
+      volume = 0;
     }
-    while (tail != head && i < nbSamples)
-    {
-        console.log("Head != Tail et i < nbSamples, head: ", head);
-        for (let c = 0; c < nbChannels; c++) {
-        output[c][i] = this.storage[tail];
-        // output[c][i] = Math.random() * 2 - 1;
-        //output[c][i] = this.storage[tail] * volume;
+
+    // While loop to read
+    while (tail != head && i < nbSamples) {
+      for (let c = 0; c < nbChannels; ++c) {
+        output[c][i] = this.storage[tail] * volume;
         tail++;
-        if (tail == this.storage.length) {
-            tail = 0;
-        }
+        if (tail === this.storage.length) {
+          tail = 0;
         }
-        i++;
+      }
+      i++;
     }
+
     Atomics.store(this.tail, 0, tail * 4);
-    //Atomics.store(this.can_write, 0, 1);
-    //Atomics.notify(this.can_write, 0);  
+    Atomics.store(this.can_write, 0, 1);
+    Atomics.notify(this.can_write, 0);
     return true;
-    }
+  }
 }
 
 registerProcessor('worklet-processor', Processor);
\ No newline at end of file
diff --git a/modules/audio_output/webaudio/webaudio.c b/modules/audio_output/webaudio/webaudio.c
index 6d9e96a8..27e34c19 100644
--- a/modules/audio_output/webaudio/webaudio.c
+++ b/modules/audio_output/webaudio/webaudio.c
@@ -4,46 +4,37 @@
 #include <string.h>
 #include <stdbool.h>
 #include <emscripten.h>
+#include <stdatomic.h>
 
 #include "webaudio.h"
 
-int audio_worklet_push(float *buffer, void *user_data, size_t data_size)
+int audio_worklet_push(void *user_data, uint8_t *buffer, size_t data_size)
 {
-    printf("PUSH\n");
-    sound_buffer_t *sab = (sound_buffer_t*)user_data;
+    // Casting
+    sound_buffer_t *sab = (sound_buffer_t *) user_data;
+    int8_t *sab_view = sab->storage;
+    uint32_t head = atomic_load(&sab->head);
+    // printf("Value of head after atomic_load(&sab->head): %d\n", head);
+    uint32_t volume = sab->volume;
 
-    float *sab_view = sab->storage;
-    int32_t head = sab->head;
-    int32_t tail = sab->tail;
-    int32_t volume = sab->volume;
-    if (!sab->can_write)
+    if (head + data_size > STORAGE_SIZE)
     {
-        return -1;
-    }
-    // TODO: check that we do not write on unconsumed data.
-    if (head + data_size > STORAGE_SIZE) {
-    // Copy the part of the data at the buffer end
-        int32_t data_size_copy_end = STORAGE_SIZE - head;
+        // Copies the part of the data at the buffer end
+        unsigned data_size_copy_end = STORAGE_SIZE - head;
         memcpy(sab_view + head, buffer, data_size_copy_end);
         head = 0;
 
-        // Copy the part of the data at the buffer start
-        int32_t data_size_copy_start = data_size - data_size_copy_end;
+        // Copies the part of the data at the buffer start
+        unsigned data_size_copy_start = data_size - data_size_copy_end;
         memcpy(sab_view + head, buffer, data_size_copy_start);
         head = data_size_copy_start;
     }
-    else {
+    else
+    {
         memcpy(sab_view + head, buffer, data_size);
         head += data_size;
     }
-    sab->head = head;
-    printf("SAB HEAD: %d\n", sab->head);
-    return 0;  // return success to indicate successful push.
-}
-
-int is_pushed(void *result)
-{
-    if (result == NULL)
-        return 1;
-    return 0;
-}
+    // Stores head
+    atomic_store(&sab->head, head);
+    return 0; // Returns success to indicate successful push.
+}
\ No newline at end of file
diff --git a/modules/audio_output/webaudio/webaudio.h b/modules/audio_output/webaudio/webaudio.h
index d37a02ba..c6d1966e 100644
--- a/modules/audio_output/webaudio/webaudio.h
+++ b/modules/audio_output/webaudio/webaudio.h
@@ -2,32 +2,31 @@
 #include <stdint.h>
 #include <stdbool.h>
 #include <stdlib.h>
+#include <stdatomic.h>
 
 #define STORAGE_SIZE 1024 * 1024
 
 typedef struct sound_buffer_t {
-    int32_t head;
-    int32_t tail;
-    int32_t volume;
-    float storage[STORAGE_SIZE];
-    int32_t is_paused;
-    int32_t can_write;
-    int32_t is_muted;
+    _Atomic uint32_t is_paused;
+    _Atomic uint32_t head;
+    _Atomic uint32_t tail;
+    _Atomic uint32_t can_write;
+    _Atomic uint32_t volume;
+    _Atomic uint32_t is_muted;
+    int8_t storage[STORAGE_SIZE];
 } sound_buffer_t;
 
-//TODO enum for indexes of the struct sound buffer, to be easier to notify/wait/store
 typedef enum indexes
 {
-    HEAD = 0,
-    TAIL = 1,
-    VOLUME = 2,
-    STORAGE = 3,
-    IS_PAUSED = STORAGE_SIZE + 3,
-    CAN_WRITE = STORAGE_SIZE + 4,
-    IS_MUTED = STORAGE_SIZE + 5,
+    IS_PAUSED = 0,
+    HEAD = 1,
+    TAIL = 2,
+    CAN_WRITE = 3,
+    VOLUME = 4, 
+    IS_MUTED = 5,
+    STORAGE = 6,
 } indexes;
 
 extern sound_buffer_t *init(int sampleRate, int nbChannels, bool aloneMemory);
 extern void js_index_wait(sound_buffer_t *bufferPtr, indexes ind, int index);
-extern void js_index_store(sound_buffer_t *bufferPtr, indexes ind, int value);
-int audio_worklet_push(float *buffer, void *user_data, size_t data_size);
+int audio_worklet_push(void *user_data, uint8_t *buffer, size_t data_size);
\ No newline at end of file
diff --git a/modules/audio_output/webaudio/webaudio.js b/modules/audio_output/webaudio/webaudio.js
index 437f880a..7bfc5ce4 100644
--- a/modules/audio_output/webaudio/webaudio.js
+++ b/modules/audio_output/webaudio/webaudio.js
@@ -1,112 +1,77 @@
 const STORAGE_SIZE = 1024 * 1024;
-const STRUCT_SIZE = 28;
+const STRUCT_SIZE = 24;
 
 mergeInto(LibraryManager.library, {
   init: function (sampleRate, nbChannels, aloneMemory)
-    {      
-      console.log("INIT");
-      var STORAGE_SIZE = 1024 * 1024;
-      var STRUCT_SIZE = 28;
+  {
+    console.log("INIT");
+    var STORAGE_SIZE = 1024 * 1024;
+    var STRUCT_SIZE = 24;
 
-      var audioCtx = new AudioContext();
-      audioCtx.sampleRate = sampleRate;
-      audioCtx.suspend();
+    var audioCtx = new AudioContext();
+    audioCtx.sampleRate = sampleRate;
 
-      if (audioCtx.destination.channelCount < nbChannels) {
-        console.log("Max number of channels of the browser is ", audioCtx.destination.channelCount)
-        nbChannels = audioCtx.destination.channelCount;
-      }
+    Module.audiocontext = audioCtx;
 
-      const playButton = document.getElementById('button')
-	/*
-      playButton.onclick = function() {
-        if(audioCtx.state === 'running') {
-          audioCtx.suspend().then(function() {
-            playButton.textContent = 'Resume context';
-          });
-        } else if(audioCtx.state === 'suspended') {
-          audioCtx.resume().then(function() {
-            playButton.textContent = 'Suspend context';
-          });
-        }
-      }
-	*/
-        if (aloneMemory) {
-            var soundBufferPtr = Module._malloc(STORAGE_SIZE + STRUCT_SIZE);
-        }
-		
-		var offset = soundBufferPtr;
-          // Needs otimization, be careful with the struct and the offset, and the sizes
-          
-          // Offset : if Int32 -> 32/8 * nmem
-          //          if Int8 -> 8/8 * nmem
-          
-          // Offset here is 0
-      var msg = {};
-		  msg["type"] = "recv-audio-queue";
-      msg["head"] = new Int32Array(wasmMemory.buffer, offset, 1);
-      console.log("Offset @head ", offset);
-      offset += (32 / 8) * 1
-      // here 4 * 1 because 0 + 32/8 * 1
-      msg["tail"] = new Int32Array(wasmMemory.buffer, offset, 1);
-      console.log("Offset @tail ", offset);
-      offset += (32 / 8) * 1
-      // here 4 * 2 because 4 + 32/8 * 1
-      msg["volume"] = new Int32Array(wasmMemory.buffer, offset, 1);
-      console.log("Offset @volume ", offset);
-      offset += (32 / 8) * 1
-      // here 4 * 3 because 8 + 32/8 * 1
-      msg["storage"] = new Float32Array(wasmMemory.buffer, offset, STORAGE_SIZE);
-      console.log("Offset @storage ", offset);
-      offset += (32 / 8) * STORAGE_SIZE
-      // here, 12 + (32/8) * (this.STORAGE_SIZE / 4) = 2097164
-      msg["is_paused"] = new Int32Array(wasmMemory.buffer, offset, 1);
-      console.log("Offset @pause ", offset);
-      offset += (32 / 8) * 1
-      msg["can_write"] = new Int32Array(wasmMemory.buffer, offset, 1)
-      msg["can_write"][0] = 1;
-      console.log("Offset @can_write", offset);
-      offset += (32 / 8) * 1
-      msg["is_muted"] = new Int32Array(wasmMemory.buffer, offset, 1);
-      console.log("Offset @is_muted", offset);
+    audioCtx.suspend();
+
+    if (audioCtx.destination.channelCount < nbChannels) {
+      console.log("Max number of channels of the browser is ", audioCtx.destination.channelCount)
+      nbChannels = audioCtx.destination.channelCount;
+    }
+
+    if (aloneMemory) {
+      var soundBufferPtr = Module._malloc(STORAGE_SIZE + STRUCT_SIZE);
+    }
 
-      audioCtx.audioWorklet.addModule('audio-worklet-processor.js')
+    var offset = soundBufferPtr;
+
+    var msg = {};
+
+    msg["type"] = "recv-audio-queue";
+    msg["is_paused"] = new Int32Array(wasmMemory.buffer, offset, 1);
+    msg["is_paused"][0] = 1;
+    console.log("Offset @pause ", offset);
+    offset += (32 / 8) * 1
+    msg["head"] = new Int32Array(wasmMemory.buffer, offset, 1);
+    console.log("Offset @head ", offset);
+    offset += (32 / 8) * 1
+    msg["tail"] = new Int32Array(wasmMemory.buffer, offset, 1);
+    console.log("Offset @tail ", offset);
+    offset += (32 / 8) * 1
+    msg["can_write"] = new Int32Array(wasmMemory.buffer, offset, 1)
+    msg["can_write"][0] = 1;
+    console.log("Offset @can_write", offset);
+    offset += (32 / 8) * 1
+    msg["volume"] = new Int32Array(wasmMemory.buffer, offset, 1);
+    console.log("Offset @volume ", offset);
+    offset += (32 / 8) * 1
+    msg["is_muted"] = new Int32Array(wasmMemory.buffer, offset, 1);
+    console.log("Offset @is_muted", offset);
+    offset += (32 / 8) * 1
+    // Storage capacity for Storage
+    var storageCapacity = STORAGE_SIZE / 4;
+    msg["storage"] = new Float32Array(wasmMemory.buffer, offset, storageCapacity);
+    console.log("Offset @storage ", offset);
+
+    audioCtx.audioWorklet.addModule('./vlc/modules/audio_output/webaudio/audio-worklet-processor.js')
         .then(() => {
           const node = new AudioWorkletNode(audioCtx, 'worklet-processor', {
             numberOfInputs: 0,
             numberOfOutputs: 1,
-            outputChannelCount: [2]
+            outputChannelCount: [nbChannels]
           });
           node.connect(audioCtx.destination)
-          console.log('Connected')
-         
-          node["port"].postMessage(msg);   
-        })
+          node["port"].postMessage(msg);
+          console.log('Connected');
 
-      
-        // var blob = this.createAudioWorkletBlob()
-        // var url = URL.createObjectURL(blob)
+          // Doit-on call 'emscripten_request_animation_frame_loop(requestAnimationFrame_cb, this);'
+        })
 
-        // await context.audioWorklet.addModule(url)
-        // .then());
-        // const sineNode = new AudioWorkletNode(context, 'sine')
-        // sineNode.connect(context.destination)
-        // console.log('Connected')
-		return (soundBufferPtr);
-    },
-    js_index_wait: function(bufferPtr, index, value)
-    {
-        var buffer = new Int32Array(wasmMemory.buffer, bufferPtr + index, 1);
-        Atomics.wait(buffer, 0, value);
-    },
-    js_index_notify: function(bufferPtr, index)
-    {
-        var buffer = new Int32Array(wasmMemory.buffer, bufferPtr + index, 1);
-        Atomics.notify(buffer, 0, 0);
-    },
-    js_index_store: function(bufferPtr, index, value)
-    {
-        var buffer = new Int32Array(wasmMemory.buffer, bufferPtr + index, 1);
-        Atomics.store(buffer, 0, value);
-    }
-})
+    return (soundBufferPtr);
+  },
+  js_index_wait: function(bufferPtr, index, value) {
+    var buffer = new Int32Array(wasmMemory.buffer, bufferPtr + (index * 4), 1);
+    Atomics.wait(buffer, 0, value);
+  }
+})
\ No newline at end of file
-- 
2.34.1.windows.1

