From c90c09ce45d2dc4b1b0a6a714372a2d4731cd2f0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jukka=20Jyl=C3=A4nki?= <jujjyl@gmail.com>
Date: Sat, 26 Aug 2017 21:15:56 +0300
Subject: [PATCH 04/23] Add a test for asynchronously proxying calls from a
 pthread to the main thread.

---
 tests/pthread/call_async_on_main_thread.c  | 10 ++++++++++
 tests/pthread/call_async_on_main_thread.js | 12 ++++++++++++
 tests/runner.py                            |  2 +-
 tests/test_browser.py                      |  6 ++++++
 4 files changed, 29 insertions(+), 1 deletion(-)
 create mode 100644 tests/pthread/call_async_on_main_thread.c
 create mode 100644 tests/pthread/call_async_on_main_thread.js

diff --git a/tests/pthread/call_async_on_main_thread.c b/tests/pthread/call_async_on_main_thread.c
new file mode 100644
index 000000000..b46f5f83c
--- /dev/null
+++ b/tests/pthread/call_async_on_main_thread.c
@@ -0,0 +1,10 @@
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+
+extern void report_result(int param1, int param2, int param3);
+
+int main()
+{
+	report_result(1, 2, 3);
+}
diff --git a/tests/pthread/call_async_on_main_thread.js b/tests/pthread/call_async_on_main_thread.js
new file mode 100644
index 000000000..f70198dc5
--- /dev/null
+++ b/tests/pthread/call_async_on_main_thread.js
@@ -0,0 +1,12 @@
+mergeInto(LibraryManager.library, {
+  // Test asynchronously calling a function on the main thread.
+  report_result__proxy: 'async',
+  report_result__sig: 'viii',
+  report_result: function(param1, param2, param3) {
+    if (ENVIRONMENT_IS_WORKER) {
+      console.error('This function should be getting called on the main thread!');
+    }
+    console.log('got ' + param1 + ' ' + param2 + ' ' + param3);
+    __ReportResult(param1 + param2 * param3, 0);
+  }
+});
diff --git a/tests/runner.py b/tests/runner.py
index 3054e5de2..05da71883 100755
--- a/tests/runner.py
+++ b/tests/runner.py
@@ -819,7 +819,7 @@ class BrowserCore(RunnerCore):
   #define __REPORT_RESULT_DEFINED__
   #include <emscripten.h>
 
-  static void _ReportResult(int result, int sync)
+  static void EMSCRIPTEN_KEEPALIVE _ReportResult(int result, int sync)
   {
     EM_ASM({
       var xhr = new XMLHttpRequest();
diff --git a/tests/test_browser.py b/tests/test_browser.py
index 0f21e7e64..b487e5480 100644
--- a/tests/test_browser.py
+++ b/tests/test_browser.py
@@ -3324,6 +3324,12 @@ window.close = function() {
     self.btest(path_from_root('tests', 'pthread', 'call_sync_on_main_thread.c'), expected='1', args=['-O3', '-s', 'USE_PTHREADS=1', '-DPROXY_TO_PTHREAD=0', '--js-library', path_from_root('tests', 'pthread', 'call_sync_on_main_thread.js')])
     self.btest(path_from_root('tests', 'pthread', 'call_sync_on_main_thread.c'), expected='1', args=['-Oz', '-DPROXY_TO_PTHREAD=0', '--js-library', path_from_root('tests', 'pthread', 'call_sync_on_main_thread.js')])
 
+  # Test that it is possible to asynchronously call a JavaScript function on the main thread.
+  def test_pthread_call_async_on_main_thread(self):
+    self.btest(path_from_root('tests', 'pthread', 'call_async_on_main_thread.c'), expected='7', args=['-O3', '-s', 'USE_PTHREADS=1', '-s', 'PROXY_TO_PTHREAD=1', '-DPROXY_TO_PTHREAD=1', '--js-library', path_from_root('tests', 'pthread', 'call_async_on_main_thread.js')])
+    self.btest(path_from_root('tests', 'pthread', 'call_async_on_main_thread.c'), expected='7', args=['-O3', '-s', 'USE_PTHREADS=1', '-DPROXY_TO_PTHREAD=0', '--js-library', path_from_root('tests', 'pthread', 'call_async_on_main_thread.js')])
+    self.btest(path_from_root('tests', 'pthread', 'call_async_on_main_thread.c'), expected='7', args=['-Oz', '-DPROXY_TO_PTHREAD=0', '--js-library', path_from_root('tests', 'pthread', 'call_async_on_main_thread.js')])
+
   # test atomicrmw i64
   def test_atomicrmw_i64(self):
     Popen([PYTHON, EMCC, path_from_root('tests', 'atomicrmw_i64.ll'), '-s', 'USE_PTHREADS=1', '-s', 'IN_TEST_HARNESS=1', '-o', 'test.html']).communicate()
-- 
2.14.1

