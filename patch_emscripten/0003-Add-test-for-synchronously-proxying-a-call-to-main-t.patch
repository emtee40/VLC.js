From 5697581451fecb98b1ce965da77187a80b0c7b04 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jukka=20Jyl=C3=A4nki?= <jujjyl@gmail.com>
Date: Sat, 26 Aug 2017 20:42:00 +0300
Subject: [PATCH 03/23] Add test for synchronously proxying a call to main
 thread and getting a value back.

---
 src/library_pthread.js                    | 36 +++++++++++++++++++++++++++++++
 tests/pthread/call_sync_on_main_thread.c  | 30 ++++++++++++++++++++++++++
 tests/pthread/call_sync_on_main_thread.js | 28 ++++++++++++++++++++++++
 tests/test_browser.py                     |  8 ++++++-
 4 files changed, 101 insertions(+), 1 deletion(-)
 create mode 100644 tests/pthread/call_sync_on_main_thread.c
 create mode 100644 tests/pthread/call_sync_on_main_thread.js

diff --git a/src/library_pthread.js b/src/library_pthread.js
index f438799b7..309717623 100644
--- a/src/library_pthread.js
+++ b/src/library_pthread.js
@@ -262,6 +262,42 @@ var LibraryPThread = {
         var worker = new Worker(pthreadMainJs);
 
         worker.onmessage = function(e) {
+          // TODO: Move the proxied call mechanism into a queue inside heap.
+          if (e.data.proxiedCall) {
+            var returnValue;
+            var funcTable = (e.data.func >= 0) ? proxiedFunctionTable : ASM_CONSTS;
+            var funcIdx = (e.data.func >= 0) ? e.data.func : (-1 - e.data.func);
+            PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct; // Sometimes we need to backproxy events to the calling thread (e.g. HTML5 DOM events handlers such as emscripten_set_mousemove_callback()), so keep track in a globally accessible variable about the thread that initiated the proxying.
+            switch(e.data.proxiedCall) {
+              case 1: case 21: returnValue = funcTable[funcIdx](); break;
+              case 2: returnValue = funcTable[funcIdx](e.data.p0); break;
+              case 3: returnValue = funcTable[funcIdx](e.data.p0, e.data.p1); break;
+              case 4: returnValue = funcTable[funcIdx](e.data.p0, e.data.p1, e.data.p2); break;
+              case 5: returnValue = funcTable[funcIdx](e.data.p0, e.data.p1, e.data.p2, e.data.p3); break;
+              case 6: returnValue = funcTable[funcIdx](e.data.p0, e.data.p1, e.data.p2, e.data.p3, e.data.p4); break;
+              case 7: returnValue = funcTable[funcIdx](e.data.p0, e.data.p1, e.data.p2, e.data.p3, e.data.p4, e.data.p5); break;
+              case 8: returnValue = funcTable[funcIdx](e.data.p0, e.data.p1, e.data.p2, e.data.p3, e.data.p4, e.data.p5, e.data.p6); break;
+              case 9: returnValue = funcTable[funcIdx](e.data.p0, e.data.p1, e.data.p2, e.data.p3, e.data.p4, e.data.p5, e.data.p6, e.data.p7); break;
+              case 10: returnValue = funcTable[funcIdx](e.data.p0, e.data.p1, e.data.p2, e.data.p3, e.data.p4, e.data.p5, e.data.p6, e.data.p7, e.data.p8); break;
+              default:
+                if (e.data.proxiedCall) {
+                  Module['printErr']("worker sent an unknown proxied call idx " + e.data.proxiedCall);
+                  console.error(e.data);
+                }
+                break;
+            }
+            if (e.data.returnValue) {
+              if (e.data.proxiedCall != 21) HEAP32[e.data.returnValue >> 2] = returnValue;
+              else HEAPF64[e.data.returnValue >> 3] = returnValue;
+            }
+            var waitAddress = e.data.waitAddress;
+            if (waitAddress) {
+              Atomics.store(HEAP32, waitAddress >> 2, 1);
+              Atomics.wake(HEAP32, waitAddress >> 2, 1);
+            }
+            return;
+          }
+
           // If this message is intended to a recipient that is not the main thread, forward it to the target thread.
           if (e.data.targetThread && e.data.targetThread != _pthread_self()) {
             var thread = PThread.pthreads[e.data.targetThread];
diff --git a/tests/pthread/call_sync_on_main_thread.c b/tests/pthread/call_sync_on_main_thread.c
new file mode 100644
index 000000000..2f4ca38aa
--- /dev/null
+++ b/tests/pthread/call_sync_on_main_thread.c
@@ -0,0 +1,30 @@
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+
+extern void getDomElementInnerHTML(const char *domElement, char *dst, int size);
+extern int isThisInWorker(void);
+extern int isThisInWorkerOnMainThread(void);
+extern int receivesAndReturnsAnInteger(int i);
+
+// Define this if compiling via -s PROXY_TO_PTHREAD=1
+// #define PROXY_TO_PTHREAD 1
+
+int main()
+{
+	char dst[256];
+	char name[7] = "resize";
+	getDomElementInnerHTML(name, dst, sizeof(dst));
+	memset(name, 0, sizeof(name)); // Try to uncover if there might be a race condition and above line was not synchronously processed, and we could take name string away.
+	int inWorker1 = isThisInWorker(); // Build this application with -s USE_PTHREADS=1 -s PROXY_TO_PTHREAD=1 for this to return 1, otherwise returns 0.
+	int inWorker2 = isThisInWorkerOnMainThread(); // This should always return 0
+	int returnedInt = receivesAndReturnsAnInteger(4);
+	printf("text: \"%s\". inWorker1: %d, inWorker2: %d, returnedInt: %d\n", dst, inWorker1, inWorker2, returnedInt);
+	assert(!strstr(dst, "Resize canvas"));
+	assert(inWorker1 == PROXY_TO_PTHREAD);
+	assert(inWorker2 == 0);
+	assert(returnedInt == 42 + 4);
+#ifdef REPORT_RESULT
+	REPORT_RESULT(1);
+#endif
+}
diff --git a/tests/pthread/call_sync_on_main_thread.js b/tests/pthread/call_sync_on_main_thread.js
new file mode 100644
index 000000000..3a9e57b44
--- /dev/null
+++ b/tests/pthread/call_sync_on_main_thread.js
@@ -0,0 +1,28 @@
+mergeInto(LibraryManager.library, {
+  // Test accessing a DOM element on the main thread.
+  // This function returns the inner text of the div by ID "status"
+  // Because it accesses the DOM, it must be called on the main thread.
+  getDomElementInnerHTML__proxy: 'main',
+  getDomElementInnerHTML__sig: 'viii',
+  getDomElementInnerHTML: function(domElementId, dst, size) {
+    var id = UTF8ToString(domElementId);
+    var text = document.getElementById(id).innerHTML;
+    stringToUTF8(text, dst, size);
+  },
+
+  receivesAndReturnsAnInteger__proxy: 'main',
+  receivesAndReturnsAnInteger__sig: 'ii',
+  receivesAndReturnsAnInteger: function(i) {
+    return i + 42;
+  },
+
+  isThisInWorker: function() {
+    return ENVIRONMENT_IS_WORKER;
+  },
+
+  isThisInWorkerOnMainThread__proxy: 'main',
+  isThisInWorkerOnMainThread__sig: 'i',
+  isThisInWorkerOnMainThread: function() {
+    return ENVIRONMENT_IS_WORKER;
+  }
+});
diff --git a/tests/test_browser.py b/tests/test_browser.py
index 033248405..0f21e7e64 100644
--- a/tests/test_browser.py
+++ b/tests/test_browser.py
@@ -3318,6 +3318,12 @@ window.close = function() {
   def test_pthread_run_on_main_thread_flood(self):
     self.btest(path_from_root('tests', 'pthread', 'test_pthread_run_on_main_thread_flood.cpp'), expected='0', args=['-O3', '-s', 'USE_PTHREADS=2', '-s', 'PTHREAD_POOL_SIZE=1', '--separate-asm'], timeout=30)
 
+  # Test that it is possible to synchronously call a JavaScript function on the main thread and get a return value back.
+  def test_pthread_call_sync_on_main_thread(self):
+    self.btest(path_from_root('tests', 'pthread', 'call_sync_on_main_thread.c'), expected='1', args=['-O3', '-s', 'USE_PTHREADS=1', '-s', 'PROXY_TO_PTHREAD=1', '-DPROXY_TO_PTHREAD=1', '--js-library', path_from_root('tests', 'pthread', 'call_sync_on_main_thread.js')])
+    self.btest(path_from_root('tests', 'pthread', 'call_sync_on_main_thread.c'), expected='1', args=['-O3', '-s', 'USE_PTHREADS=1', '-DPROXY_TO_PTHREAD=0', '--js-library', path_from_root('tests', 'pthread', 'call_sync_on_main_thread.js')])
+    self.btest(path_from_root('tests', 'pthread', 'call_sync_on_main_thread.c'), expected='1', args=['-Oz', '-DPROXY_TO_PTHREAD=0', '--js-library', path_from_root('tests', 'pthread', 'call_sync_on_main_thread.js')])
+
   # test atomicrmw i64
   def test_atomicrmw_i64(self):
     Popen([PYTHON, EMCC, path_from_root('tests', 'atomicrmw_i64.ll'), '-s', 'USE_PTHREADS=1', '-s', 'IN_TEST_HARNESS=1', '-o', 'test.html']).communicate()
@@ -3623,4 +3629,4 @@ window.close = function() {
 
   # Tests the Emscripten HTML5 API emscripten_set_canvas_element_size() and emscripten_get_canvas_element_size() functionality in singlethreaded programs.
   def test_emscripten_set_canvas_element_size(self):
-    self.btest('emscripten_set_canvas_element_size.c', expected='1')
\ No newline at end of file
+    self.btest('emscripten_set_canvas_element_size.c', expected='1')
-- 
2.14.1

